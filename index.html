<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Kid-Needs Pie – fractal grouping</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #fafafa;
        --text: #222;
        --accent: #4a90e2;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      #toolbar {
        flex: 0 0 auto;
        padding: 10px 16px;
        background: #fff;
        border-bottom: 1px solid #e0e0e0;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: center;
      }
      #granularityWrap {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      #granularity {
        width: clamp(220px, 40vw, 520px);
      }
      #detail {
        font-size: 1.02rem;
      }
      #pieBox {
        flex: 1 1 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }
      svg#pie {
        max-width: 90vw;
        max-height: 90vh;
      }
      .slice {
        stroke: #fff;
        stroke-width: 2;
        cursor: pointer;
        transition: opacity 0.2s;
      }
      .slice:hover {
        opacity: 0.85;
      }
      .labels {
        pointer-events: none;
        font-size: 12px;
        fill: var(--text);
      }
      small.muted {
        color: #666;
      }
    </style>
    <!-- D3 -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  </head>
  <body>
    <div id="toolbar">
      <div id="granularityWrap">
        <label for="granularity"><b>Group granularity</b></label>
        <input
          id="granularity"
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0"
        />
        <small class="muted" id="granularityHint">coarse</small>
      </div>
      <div id="detail">Click a slice to see details</div>
    </div>

    <div id="pieBox">
      <svg
        id="pie"
        viewBox="0 0 500 500"
        preserveAspectRatio="xMidYMid meet"
      ></svg>
    </div>

    <script>
      /* ---------- CONFIG (base categories) ---------- */
      const GROUPS = [
        "Food",
        "Health",
        "Emotion",
        "Play",
        "Safety",
        "Learning",
        "Body",
        "Routine",
        "Social",
        "Rest",
      ];

      /* ---------- RAW WORD LIST ---------- */
      const RAW = `
tummy hurt,snack,hunger,apple,soup,bread,thirsty,water,milk,juice
scary dream,hug,mom,dad,comfort,cry,soft toy,blanket,night light
fall,scrape,bandage,bleeding,ice,clean wound,doctor,nurse,medicine
happy,laugh,smile,friend,share,toy,ball,game,run,jump
puzzle,blocks,lego,learn,curious,question,why,story,book,color
hot,stove,fire,sharp,knife,traffic,helmet,seatbelt,stranger,safe
tired,yawn,nap,bed,pillow,quiet,dark room,lullaby,sleep,rest
potty,toilet,wash hands,soap,dirty,shower,bath,towel,clean clothes
hair tangle,brush,comb,mirror,look nice,dress up,shoes,tie laces
lonely,playmate,brother,sister,invite,join game,hug,hold hands
new place,hide,shy,hold finger,adapt,explore,map,ask,guide
birthday,party,cake,candle,sing,dance,music,game,prize,balloon
rain,coat,umbrella,boots,puddle,splash,cold,hot cocoa,warm
school,bag,pencil,notebook,teacher,ask,answer,friend,raise hand
homework,hard,help,explain,practice,try again,proud,stickers
sunscreen,hat,sunny,outside,park,slide,swing,sand,bucket,spade
allergy,nuts,eggs,itchy,rash,check label,Epipen,alert,teacher
visiting,grandma,grandpa,kiss,story,candy,extra TV,late sleep
pet,dog,cat,feed,water,walk,fur,cuddle,lick,responsibility
sick,fever,thermometer,medicine,stay home,soup,rest,quiet,recover
`;

      /* ---------- Base grouping heuristic ---------- */
      function guessGroup(w) {
        const s = w.toLowerCase();
        if (
          /tummy|hunger|apple|soup|bread|thirst|water|milk|juice|snack|cake|candy|nut|egg/i.test(
            s
          )
        )
          return "Food";
        if (
          /hurt|scrape|bleed|doctor|medicine|fever|therm|rash|allergy|epipen|sick|recover/i.test(
            s
          )
        )
          return "Health";
        if (
          /scary|dream|hug|mom|dad|comfort|cry|happy|laugh|smile|lonely|shy/i.test(
            s
          )
        )
          return "Emotion";
        if (
          /toy|ball|game|puzzle|block|lego|run|jump|slide|swing|splash|dance|music|prize|balloon/i.test(
            s
          )
        )
          return "Play";
        if (
          /hot|stove|fire|sharp|knife|traffic|helmet|seatbelt|stranger|safe|umbrella|coat|boot/i.test(
            s
          )
        )
          return "Safety";
        if (
          /school|book|story|color|learn|question|why|homework|pencil|notebook|teacher|practice/i.test(
            s
          )
        )
          return "Learning";
        if (
          /potty|toilet|wash|soap|bath|shower|towel|brush|comb|shoes|laces|hair|dress/i.test(
            s
          )
        )
          return "Body";
        if (
          /nap|bed|sleep|rest|quiet|dark|lullaby|yawn|pillow|routine/i.test(s)
        )
          return "Rest";
        if (
          /birthday|party|friend|share|invite|brother|sister|playmate|grandma|grandpa|visit/i.test(
            s
          )
        )
          return "Social";
        return "Routine";
      }

      /* ---------- Build nodes ---------- */
      const nodes = [
        ...new Set(
          RAW.split(/[\n,]+/)
            .map((s) => s.trim())
            .filter(Boolean)
        ),
      ].map((label) => ({
        id: crypto.randomUUID(),
        label,
        baseGroup: guessGroup(label),
      }));

      const idByLabel = new Map(nodes.map((n) => [n.label, n.id]));
      const nodeById = new Map(nodes.map((n) => [n.id, n]));

      /* ---------- Build weighted links ---------- */
      const links = [];
      const add = (a, b, w) => {
        const sa = idByLabel.get(a),
          sb = idByLabel.get(b);
        if (sa && sb) links.push({ source: sa, target: sb, w });
      };

      /* (Same associations as before) */
      add("tummy hurt", "hunger", 0.95);
      add("tummy hurt", "snack", 0.8);
      add("hunger", "apple", 0.9);
      add("thirsty", "water", 0.95);
      add("apple", "juice", 0.6);
      add("soup", "bread", 0.7);
      add("fall", "scrape", 0.9);
      add("scrape", "bandage", 0.9);
      add("bleeding", "clean wound", 0.85);
      add("allergy", "nuts", 0.9);
      add("fever", "medicine", 0.9);
      add("scary dream", "hug", 0.95);
      add("hug", "mom", 0.9);
      add("cry", "comfort", 0.9);
      add("happy", "laugh", 0.9);
      add("lonely", "hug", 0.8);
      add("ball", "run", 0.7);
      add("puzzle", "blocks", 0.8);
      add("game", "laugh", 0.6);
      add("slide", "swing", 0.7);
      add("splash", "puddle", 0.9);
      add("hot", "stove", 0.9);
      add("sharp", "knife", 0.9);
      add("traffic", "seatbelt", 0.95);
      add("rain", "umbrella", 0.9);
      add("book", "story", 0.9);
      add("question", "why", 0.95);
      add("homework", "help", 0.8);
      add("potty", "wash hands", 0.9);
      add("bath", "soap", 0.8);
      add("hair tangle", "brush", 0.9);
      add("tired", "yawn", 0.9);
      add("yawn", "nap", 0.9);
      add("dark room", "sleep", 0.8);
      add("birthday", "party", 0.95);
      add("party", "friend", 0.8);
      add("grandma", "story", 0.8);
      add("school", "bag", 0.8);
      add("visit", "grandma", 0.7);
      add("tummy hurt", "soup", 0.7);
      add("sick", "rest", 0.85);
      add("fall", "cry", 0.6);
      add("scary dream", "sleep", 0.6);
      add("hot", "thirsty", 0.6);
      add("homework", "tired", 0.5);
      add("lonely", "toy", 0.5);
      add("allergy", "check label", 0.8);
      add("rain", "coat", 0.9);

      /* ---------- Fractal-like component builder ---------- */
      // threshold in [0, ~0.96] -> higher == finer (smaller components)
      function buildComponents(threshold) {
        // For each base group, take nodes in that group.
        const comps = []; // [{id, name, ids:Set}]
        const compOfNode = new Map(); // nodeId -> compIdx

        let compIdx = 0;
        for (const g of GROUPS) {
          const gNodes = nodes
            .filter((n) => n.baseGroup === g)
            .map((n) => n.id);
          if (gNodes.length === 0) continue;

          // Filter links that are within this base group and above threshold
          const gSet = new Set(gNodes);
          const gLinks = links.filter(
            (l) => gSet.has(l.source) && gSet.has(l.target) && l.w >= threshold
          );

          // Build adjacency
          const adj = new Map(gNodes.map((id) => [id, new Set()]));
          for (const { source, target } of gLinks) {
            adj.get(source).add(target);
            adj.get(target).add(source);
          }

          // Connected components (within the base group given current threshold)
          const seen = new Set();
          for (const id of gNodes) {
            if (seen.has(id)) continue;
            const stack = [id];
            seen.add(id);
            const collect = new Set([id]);
            while (stack.length) {
              const cur = stack.pop();
              for (const nei of adj.get(cur) || []) {
                if (!seen.has(nei)) {
                  seen.add(nei);
                  stack.push(nei);
                  collect.add(nei);
                }
              }
            }
            const label =
              collect.size === gNodes.length ? g : `${g} • ${++compIdx}`;
            comps.push({ id: label, base: g, ids: collect });
          }
        }

        // Value for each component = internal edges + half of edges to outside
        const value = new Map(comps.map((c) => [c.id, 0]));
        const compIdOf = (nid) => {
          for (const c of comps) if (c.ids.has(nid)) return c.id;
          return null;
        };

        for (const l of links) {
          const ca = compIdOf(l.source);
          const cb = compIdOf(l.target);
          if (!ca || !cb) continue;
          if (ca === cb) value.set(ca, value.get(ca) + l.w);
          else {
            value.set(ca, value.get(ca) + l.w / 2);
            value.set(cb, value.get(cb) + l.w / 2);
          }
        }

        // Attach values and items
        for (const c of comps) {
          c.value = +(value.get(c.id) || 0);
          c.items = [...c.ids].map((id) => nodeById.get(id).label).sort();
        }

        // Only keep components with positive weight
        return comps.filter((c) => c.value > 0);
      }

      /* ---------- Pie drawing ---------- */
      const svg = d3.select("#pie");
      const width = 500,
        height = 500;
      const radius = Math.min(width, height) / 2 - 20;
      const gPie = svg
        .append("g")
        .attr("transform", `translate(${width / 2},${height / 2})`);

      const pie = d3.pie().value((d) => d.value);
      const arc = d3.arc().innerRadius(0).outerRadius(radius);
      const labelArc = d3
        .arc()
        .innerRadius(radius * 0.7)
        .outerRadius(radius * 0.7);

      function colorForIndex(i, n) {
        // Smooth spectrum for arbitrary n
        return d3.interpolateSpectral(i / Math.max(1, n - 1));
      }

      function draw(comps) {
        const arcs = pie(comps);

        const slices = gPie
          .selectAll("path.slice")
          .data(arcs, (d) => d.data.id);

        slices
          .enter()
          .append("path")
          .attr("class", "slice")
          .attr("d", arc)
          .attr("fill", (d, i) => colorForIndex(i, arcs.length))
          .on("click", (_, d) => showDetail(d.data))
          .append("title")
          .text((d) => `${d.data.id}: ${d.data.value.toFixed(2)}`);

        slices
          .transition()
          .duration(250)
          .attr("d", arc)
          .attr("fill", (d, i) => colorForIndex(i, arcs.length));

        slices.exit().remove();

        const labels = gPie
          .selectAll("text.labels")
          .data(arcs, (d) => d.data.id);

        labels
          .enter()
          .append("text")
          .attr("class", "labels")
          .attr("text-anchor", "middle")
          .attr("transform", (d) => `translate(${labelArc.centroid(d)})`)
          .text((d) => d.data.id)
          .append("title")
          .text((d) => `${d.data.id}: ${d.data.value.toFixed(2)}`);

        labels
          .transition()
          .duration(250)
          .attr("transform", (d) => `translate(${labelArc.centroid(d)})`)
          .tween("text", function (d) {
            this.textContent = d.data.id;
          });

        labels.exit().remove();
      }

      function showDetail(comp) {
        const total = comp.value.toFixed(2);
        const items = comp.items;
        document.getElementById("detail").innerHTML = `<b>${
          comp.id
        }</b> &nbsp; total link weight: <b>${total}</b> &nbsp; items: ${items
          .slice(0, 18)
          .join(", ")}${
          items.length > 18 ? ` … and ${items.length - 18} more` : ""
        }`;
      }

      /* ---------- Slider wiring ---------- */
      const slider = document.getElementById("granularity");
      const hint = document.getElementById("granularityHint");

      // Map slider [0..1] -> threshold [0..0.96]
      const toThreshold = d3.scaleLinear().domain([0, 1]).range([0, 0.96]);

      function updateFromSlider() {
        const t = +slider.value;
        hint.textContent =
          t < 0.05
            ? "coarse"
            : t > 0.95
            ? "atomic"
            : `fine ${Math.round(t * 100)}%`;
        const threshold = toThreshold(t);
        const comps = buildComponents(threshold);
        draw(comps);
        // Clear detail on update
        document.getElementById("detail").textContent =
          "Click a slice to see details";
      }

      slider.addEventListener("input", updateFromSlider);

      // Initial render
      updateFromSlider();
    </script>
  </body>
</html>
